if(!FPhi)var FPhi={};if(void 0===FPhi.Graph){class Graph{constructor(n,t,e){this.graphUrl=n,this.graphReadyEvent=t,this.graphNewStateEvent=e,this.xmlHttpWidget=new XMLHttpRequest,this.xmlHttpWidget.onreadystatechange=this.readyEvent.bind(this),this.xmlHttpWidget.open("GET",this.graphUrl),this.xmlHttpWidget.send(null)}readyEvent(n){if(4==n.target.readyState&&200==n.target.status){var t=new DOMParser;this.xmlDoc=t.parseFromString(n.target.responseText,"text/xml"),this.graphReadyEvent()}}setInitialState(n){void 0!=this.xmlDoc.querySelector("[name='"+n+"']")&&(this.state=n,this.graphNewStateEvent(this.state))}sendMessage(n){var t=this.xmlDoc.querySelector("[name='"+this.state+"']");if(void 0!=t){var e=t.querySelector("[message='"+n+"']");if(void 0!=e||(n=n.split("//")[0],void 0!=(e=t.querySelector("[message='"+n+"']")))){var i=e.getAttribute("to");this.state=i,this.graphNewStateEvent(this.state)}}}}FPhi.Graph=Graph}!function(n){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).Animated_GIF=n()}}(function(){return function n(t,e,i){function a(o,s){if(!e[o]){if(!t[o]){var l="function"==typeof require&&require;if(!s&&l)return l(o,!0);if(r)return r(o,!0);var d=new Error("Cannot find module '"+o+"'");throw d.code="MODULE_NOT_FOUND",d}var f=e[o]={exports:{}};t[o][0].call(f.exports,function(n){var e=t[o][1][n];return a(e||n)},f,f.exports,n,t,e,i)}return e[o].exports}for(var r="function"==typeof require&&require,o=0;o<i.length;o++)a(i[o]);return a}({1:[function(n,t,e){function i(n,t,e,i){for(var a=n[t++],r=1<<a,o=r+1,s=o+1,l=a+1,d=(1<<l)-1,f=0,h=0,p=0,u=n[t++],v=new Int32Array(4096),c=null;;){for(;f<16&&0!==u;)h|=n[t++]<<f,f+=8,1===u?u=n[t++]:--u;if(f<l)break;var g=h&d;if(h>>=l,f-=l,g!==r){if(g===o)break;for(var b=g<s?g:c,m=0,x=b;x>r;)x=v[x]>>8,++m;var w=x;if(p+m+(b!==g?1:0)>i)return void console.log("Warning, gif stream longer than expected.");e[p++]=w;var y=p+=m;for(b!==g&&(e[p++]=w),x=b;m--;)x=v[x],e[--y]=255&x,x>>=8;null!==c&&s<4096&&(v[s++]=c<<8|w,s>=d+1&&l<12&&(++l,d=d<<1|1)),c=g}else s=o+1,d=(1<<(l=a+1))-1,c=null}return p!==i&&console.log("Warning, gif stream shorter than expected."),e}try{e.GifWriter=function(n,t,e,i){function a(n){var t=n.length;if(t<2||t>256||t&t-1)throw"Invalid code/color length, must be power of 2 and 2 .. 256.";return t}var r=0,o=void 0===(i=void 0===i?{}:i).loop?null:i.loop,s=void 0===i.palette?null:i.palette;if(t<=0||e<=0||t>65535||e>65535)throw"Width/Height invalid.";n[r++]=71,n[r++]=73,n[r++]=70,n[r++]=56,n[r++]=57,n[r++]=97;var l=0,d=0;if(null!==s){for(var f=a(s);f>>=1;)++l;if(f=1<<l,--l,void 0!==i.background){if((d=i.background)>=f)throw"Background index out of range.";if(0===d)throw"Background index explicitly passed as 0."}}if(n[r++]=255&t,n[r++]=t>>8&255,n[r++]=255&e,n[r++]=e>>8&255,n[r++]=(null!==s?128:0)|l,n[r++]=d,n[r++]=0,null!==s)for(var h=0,p=s.length;h<p;++h){var u=s[h];n[r++]=u>>16&255,n[r++]=u>>8&255,n[r++]=255&u}if(null!==o){if(o<0||o>65535)throw"Loop count invalid.";n[r++]=33,n[r++]=255,n[r++]=11,n[r++]=78,n[r++]=69,n[r++]=84,n[r++]=83,n[r++]=67,n[r++]=65,n[r++]=80,n[r++]=69,n[r++]=50,n[r++]=46,n[r++]=48,n[r++]=3,n[r++]=1,n[r++]=255&o,n[r++]=o>>8&255,n[r++]=0}var v=!1;this.addFrame=function(t,e,i,o,l,d){if(!0===v&&(--r,v=!1),d=void 0===d?{}:d,t<0||e<0||t>65535||e>65535)throw"x/y invalid.";if(i<=0||o<=0||i>65535||o>65535)throw"Width/Height invalid.";if(l.length<i*o)throw"Not enough pixels for the frame size.";var f=!0,h=d.palette;if(void 0!==h&&null!==h||(f=!1,h=s),void 0===h||null===h)throw"Must supply either a local or global palette.";for(var p=a(h),u=0;p>>=1;)++u;p=1<<u;var c=void 0===d.delay?0:d.delay,g=void 0===d.disposal?0:d.disposal;if(g<0||g>3)throw"Disposal out of range.";var b=!1,m=0;if(void 0!==d.transparent&&null!==d.transparent&&(b=!0,(m=d.transparent)<0||m>=p))throw"Transparent color index.";if((0!==g||b||0!==c)&&(n[r++]=33,n[r++]=249,n[r++]=4,n[r++]=g<<2|(!0===b?1:0),n[r++]=255&c,n[r++]=c>>8&255,n[r++]=m,n[r++]=0),n[r++]=44,n[r++]=255&t,n[r++]=t>>8&255,n[r++]=255&e,n[r++]=e>>8&255,n[r++]=255&i,n[r++]=i>>8&255,n[r++]=255&o,n[r++]=o>>8&255,n[r++]=!0===f?128|u-1:0,!0===f)for(var x=0,w=h.length;x<w;++x){var y=h[x];n[r++]=y>>16&255,n[r++]=y>>8&255,n[r++]=255&y}r=function(n,t,e,i){function a(e){for(;p>=e;)n[t++]=255&u,u>>=8,p-=8,t===o+256&&(n[o]=255,o=t++)}function r(n){u|=n<<p,p+=h,a(8)}n[t++]=e;var o=t++,s=1<<e,l=s-1,d=s+1,f=d+1,h=e+1,p=0,u=0,v=i[0]&l,c={};r(s);for(var g=1,b=i.length;g<b;++g){var m=i[g]&l,x=v<<8|m,w=c[x];if(void 0===w){for(u|=v<<p,p+=h;p>=8;)n[t++]=255&u,u>>=8,p-=8,t===o+256&&(n[o]=255,o=t++);4096===f?(r(s),f=d+1,h=e+1,c={}):(f>=1<<h&&++h,c[x]=f++),v=m}else v=w}return r(v),r(d),a(1),o+1===t?n[o]=0:(n[o]=t-o-1,n[t++]=0),t}(n,r,u<2?2:u,l)},this.end=function(){return!1===v&&(n[r++]=59,v=!0),r}},e.GifReader=function(n){var t=0;if(71!==n[t++]||73!==n[t++]||70!==n[t++]||56!==n[t++]||56!=(n[t++]+1&253)||97!==n[t++])throw"Invalid GIF 87a/89a header.";var e=n[t++]|n[t++]<<8,a=n[t++]|n[t++]<<8,r=n[t++],o=r>>7,s=1<<1+(7&r);n[t++],n[t++];var l=null;o&&(l=t,t+=3*s);var d=!0,f=[],h=0,p=null,u=0,v=null;for(this.width=e,this.height=a;d&&t<n.length;)switch(n[t++]){case 33:switch(n[t++]){case 255:if(11!==n[t]||78==n[t+1]&&69==n[t+2]&&84==n[t+3]&&83==n[t+4]&&67==n[t+5]&&65==n[t+6]&&80==n[t+7]&&69==n[t+8]&&50==n[t+9]&&46==n[t+10]&&48==n[t+11]&&3==n[t+12]&&1==n[t+13]&&0==n[t+16])t+=14,v=n[t++]|n[t++]<<8,t++;else for(t+=12;0!==(q=n[t++]);)t+=q;break;case 249:if(4!==n[t++]||0!==n[t+4])throw"Invalid graphics extension block.";var c=n[t++];h=n[t++]|n[t++]<<8,p=n[t++],0==(1&c)&&(p=null),u=c>>2&7,t++;break;case 254:for(;0!==(q=n[t++]);)t+=q;break;default:throw"Unknown graphic control label: 0x"+n[t-1].toString(16)}break;case 44:var g=n[t++]|n[t++]<<8,b=n[t++]|n[t++]<<8,m=n[t++]|n[t++]<<8,x=n[t++]|n[t++]<<8,w=n[t++],y=w>>6&1,P=l,k=!1;w>>7&&(k=!0,P=t,t+=3*(1<<1+(7&w)));var j=t;for(t++;;){var q;if(0===(q=n[t++]))break;t+=q}f.push({x:g,y:b,width:m,height:x,has_local_palette:k,palette_offset:P,data_offset:j,data_length:t-j,transparent_index:p,interlaced:!!y,delay:h,disposal:u});break;case 59:d=!1;break;default:throw"Unknown gif block: 0x"+n[t-1].toString(16)}this.numFrames=function(){return f.length},this.loopCount=function(){return v},this.frameInfo=function(n){if(n<0||n>=f.length)throw"Frame index out of range.";return f[n]},this.decodeAndBlitFrameBGRA=function(t,a){var r=this.frameInfo(t),o=r.width*r.height,s=new Uint8Array(o);i(n,r.data_offset,s,o);var l=r.palette_offset,d=r.transparent_index;null===d&&(d=256);var f=r.width,h=e-f,p=f,u=4*(r.y*e+r.x),v=4*((r.y+r.height)*e+r.x),c=u,g=4*h;!0===r.interlaced&&(g+=4*e*7);for(var b=8,m=0,x=s.length;m<x;++m){var w=s[m];if(0===p&&(p=f,(c+=g)>=v&&(g=4*h+4*e*(b-1),c=u+(f+h)*(b<<1),b>>=1)),w===d)c+=4;else{var y=n[l+3*w],P=n[l+3*w+1],k=n[l+3*w+2];a[c++]=k,a[c++]=P,a[c++]=y,a[c++]=255}--p}},this.decodeAndBlitFrameRGBA=function(t,a){var r=this.frameInfo(t),o=r.width*r.height,s=new Uint8Array(o);i(n,r.data_offset,s,o);var l=r.palette_offset,d=r.transparent_index;null===d&&(d=256);var f=r.width,h=e-f,p=f,u=4*(r.y*e+r.x),v=4*((r.y+r.height)*e+r.x),c=u,g=4*h;!0===r.interlaced&&(g+=4*e*7);for(var b=8,m=0,x=s.length;m<x;++m){var w=s[m];if(0===p&&(p=f,(c+=g)>=v&&(g=4*h+4*e*(b-1),c=u+(f+h)*(b<<1),b>>=1)),w===d)c+=4;else{var y=n[l+3*w],P=n[l+3*w+1],k=n[l+3*w+2];a[c++]=y,a[c++]=P,a[c++]=k,a[c++]=255}--p}}}}catch(n){}},{}],2:[function(n,t,e){t.exports=function(t){"use strict";function e(n){m.length,w=n;for(var t=0;t<l&&t<m.length;t++)i(t)}function i(n){var t,e;return(t=m[n]).beingProcessed||t.done?(console.error("Frame already being processed or done!",t.position),void r()):(t.sampleInterval=s,t.beingProcessed=!0,(e=function(){if(0===k.length)throw"No workers left!";return k.pop()}()).onmessage=function(n){var i=n.data;delete t.data,t.pixels=Array.prototype.slice.call(i.pixels),t.palette=Array.prototype.slice.call(i.palette),t.done=!0,t.beingProcessed=!1,function(n){k.push(n)}(e),r()},void e.postMessage(t))}function a(){for(var n=-1,t=0;t<m.length;t++){var e=m[t];if(!e.done&&!e.beingProcessed){n=t;break}}n>=0&&i(n)}function r(){var n=m.every(function(n){return!n.beingProcessed&&n.done});y(.75*++x/m.length),n?j||function(n,t){var e,i=[],a={loop:g};null!==p&&null!==u&&(e=u,a.palette=e);var r=new d(i,f,h,a);j=!0,n.forEach(function(t,i){var a;e||(a=t.palette),y(.75+.25*t.position*1/n.length),r.addFrame(0,0,f,h,t.pixels,{palette:a,delay:b})}),r.end(),y(1),n=[],j=!1,t(i)}(m,w):setTimeout(a,1)}function o(n){return 0!==n&&0==(n&n-1)}t=t||{};var s,l,d=n("omggif").GifWriter,f=t.width||160,h=t.height||120,p=t.dithering||null,u=t.palette||null,v=null,c=null,g=0,b=250,m=[],x=0,w=function(){},y=function(){},P=[],k=[],j=!1;if(u){if(!(u instanceof Array))throw u;if(u.length<2||u.length>256){for(console.error("Palette must hold only between 2 and 256 colours");u.length<2;)u.push(0);u.length>256&&(u=u.slice(0,256))}if(!o(u.length))for(console.error("Palette must have a power of two number of colours");!o(u.length);)u.splice(u.length-1,1)}s=(t=t||{}).sampleInterval||10,l=t.numWorkers||2;for(var q=0;q<l;q++){var C=new Worker(window.URL.createObjectURL(new Blob(['(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module \'"+o+"\'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\nfunction colorClamp(value) {\n\tif(value < 0) return 0;\n\telse if(value > 255) return 255;\n\n\treturn value;\n}\n\nvar bayerMatrix8x8 = [\n\t[  1, 49, 13, 61,  4, 52, 16, 64 ],\n\t[ 33, 17, 45, 29, 36, 20, 48, 32 ],\n\t[  9, 57,  5, 53, 12, 60,  8, 56 ],\n\t[ 41, 25, 37, 21, 44, 28, 40, 24 ],\n\t[  3, 51, 15, 63,  2, 50, 14, 62 ],\n\t[ 35, 19, 47, 31, 34, 18, 46, 30 ],\n\t[ 11, 59,  7, 55, 10, 58,  6, 54 ],\n\t[ 43, 27, 39, 23, 42, 26, 38, 22 ]\n\t];\n\n\t// int r, int g, int b, int[][] palette, int paletteLength\n\tfunction getClosestPaletteColorIndex(r, g, b, palette, paletteLength) {\n\t\tvar minDistance = 195076;\n\t\tvar diffR, diffG, diffB;\n\t\tvar distanceSquared;\n\t\tvar bestIndex = 0;\n\t\tvar paletteChannels;\n\n\t\tfor(var i = 0; i < paletteLength; i++) {\n\n\t\t\tpaletteChannels = palette[i];\n\t\t\tdiffR = r - paletteChannels[0];\n\t\t\tdiffG = g - paletteChannels[1];\n\t\t\tdiffB = b - paletteChannels[2];\n\n\t\t\tdistanceSquared = diffR*diffR + diffG*diffG + diffB*diffB;\n\n\t\t\tif(distanceSquared < minDistance) {\n\t\t\t\tbestIndex = i;\n\t\t\t\tminDistance = distanceSquared;\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestIndex;\n\t}\n\n// TODO: inPixels -> inComponents or inColors or something more accurate\nfunction BayerDithering(inPixels, width, height, palette) {\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar pixel, threshold, index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tvar modI = 8;\n\tvar modJ = 8;\n\n\tfor(var j = 0; j < height; j++) {\n\t\tvar modj = j % modJ;\n\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tthreshold = matrix[i % modI][modj];\n\n\t\t\tr = colorClamp( inPixels[offset++] + threshold );\n\t\t\tg = colorClamp( inPixels[offset++] + threshold );\n\t\t\tb = colorClamp( inPixels[offset++] + threshold );\n\n\t\t\tindex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tindexedPixels[indexedOffset++] = index;\n\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\n\nfunction ClosestDithering(inPixels, width, height, palette) {\n\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar numPixels = width * height;\n\tvar indexedPixels = new Uint8Array( numPixels );\n\n\tfor(var i = 0; i < numPixels; i++) {\n\n\t\tr = inPixels[offset++];\n\t\tg = inPixels[offset++];\n\t\tb = inPixels[offset++];\n\n\t\tindexedPixels[i] = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\n\t}\n\n\treturn indexedPixels;\n\n}\n\n\nfunction FloydSteinberg(inPixels, width, height, palette) {\n\tvar paletteLength = palette.length;\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar widthLimit = width - 1;\n\tvar heightLimit = height - 1;\n\tvar offsetNextI, offsetNextJ;\n\tvar offsetPrevINextJ;\n\tvar channels, nextChannels;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tfor(var j = 0; j < height; j++) {\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tr = colorClamp(inPixels[offset++]);\n\t\t\tg = colorClamp(inPixels[offset++]);\n\t\t\tb = colorClamp(inPixels[offset++]);\n\n\t\t\tvar colorIndex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tvar paletteColor = palette[colorIndex];\n\t\t\tvar closestColor = paletteColor[3];\n\n\t\t\t// We are done with finding the best value for this pixel\n\t\t\tindexedPixels[indexedOffset] = colorIndex;\n\n\t\t\t// Now find difference between assigned value and original color\n\t\t\t// and propagate that error forward\n\t\t\tvar errorR = r - paletteColor[0];\n\t\t\tvar errorG = g - paletteColor[1];\n\t\t\tvar errorB = b - paletteColor[2];\n\n\t\t\tif(i < widthLimit) {\n\n\t\t\t\toffsetNextI = offset + 1;\n\n\t\t\t\tinPixels[offsetNextI++] += (errorR * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorG * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorB * 7) >> 4;\n\n\t\t\t}\n\n\n\t\t\tif(j < heightLimit) {\n\n\t\t\t\tif(i > 0) {\n\n\t\t\t\t\toffsetPrevINextJ = offset - 1 + width;\n\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorR * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorG * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorB * 3) >> 4;\n\n\t\t\t\t}\n\n\t\t\t\toffsetNextJ = offset + width;\n\n\t\t\t\tinPixels[offsetNextJ++] += (errorR * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorG * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorB * 5) >> 4;\n\n\n\t\t\t\tif(i < widthLimit) {\n\n\t\t\t\t\tinPixels[offsetNextJ++] += errorR >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorG >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorB >> 4;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tindexedOffset++;\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\nmodule.exports = {\n\tBayer: BayerDithering,\n\tClosest: ClosestDithering,\n\tFloydSteinberg: FloydSteinberg\n};\n\n\n},{}],2:[function(require,module,exports){\nvar NeuQuant = require(\'./lib/NeuQuant\');\nvar Dithering = require(\'node-dithering\');\n\nfunction channelizePalette( palette ) {\n    var channelizedPalette = [];\n\n    for(var i = 0; i < palette.length; i++) {\n        var color = palette[i];\n\n        var r = (color & 0xFF0000) >> 16;\n        var g = (color & 0x00FF00) >>  8;\n        var b = (color & 0x0000FF);\n\n        channelizedPalette.push([ r, g, b, color ]);\n    }\n\n    return channelizedPalette;\n\n}\n\n\nfunction dataToRGB( data, width, height ) {\n    var i = 0;\n    var length = width * height * 4;\n    var rgb = [];\n\n    while(i < length) {\n        rgb.push( data[i++] );\n        rgb.push( data[i++] );\n        rgb.push( data[i++] );\n        i++; // for the alpha channel which we don\'t care about\n    }\n\n    return rgb;\n}\n\n\nfunction componentizedPaletteToArray(paletteRGB) {\n\n    var paletteArray = [];\n\n    for(var i = 0; i < paletteRGB.length; i += 3) {\n        var r = paletteRGB[ i ];\n        var g = paletteRGB[ i + 1 ];\n        var b = paletteRGB[ i + 2 ];\n        paletteArray.push(r << 16 | g << 8 | b);\n    }\n\n    return paletteArray;\n}\n\n\n// This is the "traditional" Animated_GIF style of going from RGBA to indexed color frames\nfunction processFrameWithQuantizer(imageData, width, height, sampleInterval) {\n\n    var rgbComponents = dataToRGB( imageData, width, height );\n    var nq = new NeuQuant(rgbComponents, rgbComponents.length, sampleInterval);\n    var paletteRGB = nq.process();\n    var paletteArray = new Uint32Array(componentizedPaletteToArray(paletteRGB));\n\n    var numberPixels = width * height;\n    var indexedPixels = new Uint8Array(numberPixels);\n\n    var k = 0;\n    for(var i = 0; i < numberPixels; i++) {\n        r = rgbComponents[k++];\n        g = rgbComponents[k++];\n        b = rgbComponents[k++];\n        indexedPixels[i] = nq.map(r, g, b);\n    }\n\n    return {\n        pixels: indexedPixels,\n        palette: paletteArray\n    };\n\n}\n\n\n// And this is a version that uses dithering against of quantizing\n// It can also use a custom palette if provided, or will build one otherwise\nfunction processFrameWithDithering(imageData, width, height, ditheringType, palette) {\n\n    // Extract component values from data\n    var rgbComponents = dataToRGB( imageData, width, height );\n\n\n    // Build palette if none provided\n    if(palette === null) {\n\n        var nq = new NeuQuant(rgbComponents, rgbComponents.length, 16);\n        var paletteRGB = nq.process();\n        palette = componentizedPaletteToArray(paletteRGB);\n\n    }\n\n    var paletteArray = new Uint32Array( palette );\n    var paletteChannels = channelizePalette( palette );\n\n    // Convert RGB image to indexed image\n    var ditheringFunction;\n\n    if(ditheringType === \'closest\') {\n        ditheringFunction = Dithering.Closest;\n    } else if(ditheringType === \'floyd\') {\n        ditheringFunction = Dithering.FloydSteinberg;\n    } else {\n        ditheringFunction = Dithering.Bayer;\n    }\n\n    pixels = ditheringFunction(rgbComponents, width, height, paletteChannels);\n\n    return ({\n        pixels: pixels,\n        palette: paletteArray\n    });\n\n}\n\n\n// ~~~\n\nfunction run(frame) {\n    var width = frame.width;\n    var height = frame.height;\n    var imageData = frame.data;\n    var dithering = frame.dithering;\n    var palette = frame.palette;\n    var sampleInterval = frame.sampleInterval;\n\n    if(dithering) {\n        return processFrameWithDithering(imageData, width, height, dithering, palette);\n    } else {\n        return processFrameWithQuantizer(imageData, width, height, sampleInterval);\n    }\n\n}\n\n\nself.onmessage = function(ev) {\n    var data = ev.data;\n    var response = run(data);\n    postMessage(response);\n};\n\n},{"./lib/NeuQuant":3,"node-dithering":1}],3:[function(require,module,exports){\n/*\n* NeuQuant Neural-Net Quantization Algorithm\n* ------------------------------------------\n*\n* Copyright (c) 1994 Anthony Dekker\n*\n* NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n* "Kohonen neural networks for optimal colour quantization" in "Network:\n* Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\n* the algorithm.\n*\n* Any party obtaining a copy of these files from the author, directly or\n* indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n* world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n* this software and documentation files (the "Software"), including without\n* limitation the rights to use, copy, modify, merge, publish, distribute,\n* sublicense, and/or sell copies of the Software, and to permit persons who\n* receive copies from any such party to do so, with the only requirement being\n* that this copyright notice remain intact.\n*/\n\n/*\n* This class handles Neural-Net quantization algorithm\n* @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n* @author Thibault Imbert (AS3 version - bytearray.org)\n* @version 0.1 AS3 implementation\n* @version 0.2 JS->AS3 "translation" by antimatter15\n* @version 0.3 JS clean up + using modern JS idioms by sole - http://soledadpenades.com\n* Also implement fix in color conversion described at http://stackoverflow.com/questions/16371712/neuquant-js-javascript-color-quantization-hidden-bug-in-js-conversion\n*/\n\nmodule.exports = function NeuQuant() {\n\n    var netsize = 256; // number of colours used\n\n    // four primes near 500 - assume no image has a length so large\n    // that it is divisible by all four primes\n    var prime1 = 499;\n    var prime2 = 491;\n    var prime3 = 487;\n    var prime4 = 503;\n\n    // minimum size for input image\n    var minpicturebytes = (3 * prime4);\n\n    // Network Definitions\n\n    var maxnetpos = (netsize - 1);\n    var netbiasshift = 4; // bias for colour values\n    var ncycles = 100; // no. of learning cycles\n\n    // defs for freq and bias\n    var intbiasshift = 16; // bias for fractions\n    var intbias = (1 << intbiasshift);\n    var gammashift = 10; // gamma = 1024\n    var gamma = (1 << gammashift);\n    var betashift = 10;\n    var beta = (intbias >> betashift); // beta = 1/1024\n    var betagamma = (intbias << (gammashift - betashift));\n\n    // defs for decreasing radius factor\n    // For 256 colors, radius starts at 32.0 biased by 6 bits\n    // and decreases by a factor of 1/30 each cycle\n    var initrad = (netsize >> 3);\n    var radiusbiasshift = 6;\n    var radiusbias = (1 << radiusbiasshift);\n    var initradius = (initrad * radiusbias);\n    var radiusdec = 30;\n\n    // defs for decreasing alpha factor\n    // Alpha starts at 1.0 biased by 10 bits\n    var alphabiasshift = 10;\n    var initalpha = (1 << alphabiasshift);\n    var alphadec;\n\n    // radbias and alpharadbias used for radpower calculation\n    var radbiasshift = 8;\n    var radbias = (1 << radbiasshift);\n    var alpharadbshift = (alphabiasshift + radbiasshift);\n    var alpharadbias = (1 << alpharadbshift);\n\n\n    // Input image\n    var thepicture;\n    // Height * Width * 3\n    var lengthcount;\n    // Sampling factor 1..30\n    var samplefac;\n\n    // The network itself\n    var network;\n    var netindex = [];\n\n    // for network lookup - really 256\n    var bias = [];\n\n    // bias and freq arrays for learning\n    var freq = [];\n    var radpower = [];\n\n    function NeuQuantConstructor(thepic, len, sample) {\n\n        var i;\n        var p;\n\n        thepicture = thepic;\n        lengthcount = len;\n        samplefac = sample;\n\n        network = new Array(netsize);\n\n        for (i = 0; i < netsize; i++) {\n            network[i] = new Array(4);\n            p = network[i];\n            p[0] = p[1] = p[2] = ((i << (netbiasshift + 8)) / netsize) | 0;\n            freq[i] = (intbias / netsize) | 0; // 1 / netsize\n            bias[i] = 0;\n        }\n\n    }\n\n    function colorMap() {\n        var map = [];\n        var index = new Array(netsize);\n        for (var i = 0; i < netsize; i++)\n            index[network[i][3]] = i;\n        var k = 0;\n        for (var l = 0; l < netsize; l++) {\n            var j = index[l];\n            map[k++] = (network[j][0]);\n            map[k++] = (network[j][1]);\n            map[k++] = (network[j][2]);\n        }\n        return map;\n    }\n\n    // Insertion sort of network and building of netindex[0..255]\n    // (to do after unbias)\n    function inxbuild() {\n        var i;\n        var j;\n        var smallpos;\n        var smallval;\n        var p;\n        var q;\n        var previouscol;\n        var startpos;\n\n        previouscol = 0;\n        startpos = 0;\n\n        for (i = 0; i < netsize; i++)\n        {\n\n            p = network[i];\n            smallpos = i;\n            smallval = p[1]; // index on g\n            // find smallest in i..netsize-1\n            for (j = i + 1; j < netsize; j++) {\n\n                q = network[j];\n\n                if (q[1] < smallval) { // index on g\n                    smallpos = j;\n                    smallval = q[1]; // index on g\n                }\n            }\n\n            q = network[smallpos];\n\n            // swap p (i) and q (smallpos) entries\n            if (i != smallpos) {\n                j = q[0];\n                q[0] = p[0];\n                p[0] = j;\n                j = q[1];\n                q[1] = p[1];\n                p[1] = j;\n                j = q[2];\n                q[2] = p[2];\n                p[2] = j;\n                j = q[3];\n                q[3] = p[3];\n                p[3] = j;\n            }\n\n            // smallval entry is now in position i\n            if (smallval != previouscol) {\n\n                netindex[previouscol] = (startpos + i) >> 1;\n\n                for (j = previouscol + 1; j < smallval; j++) {\n                    netindex[j] = i;\n                }\n\n                previouscol = smallval;\n                startpos = i;\n\n            }\n\n        }\n\n        netindex[previouscol] = (startpos + maxnetpos) >> 1;\n        for (j = previouscol + 1; j < 256; j++) {\n            netindex[j] = maxnetpos; // really 256\n        }\n\n    }\n\n\n    // Main Learning Loop\n\n    function learn() {\n        var i;\n        var j;\n        var b;\n        var g;\n        var r;\n        var radius;\n        var rad;\n        var alpha;\n        var step;\n        var delta;\n        var samplepixels;\n        var p;\n        var pix;\n        var lim;\n\n        if (lengthcount < minpicturebytes) {\n            samplefac = 1;\n        }\n\n        alphadec = 30 + ((samplefac - 1) / 3);\n        p = thepicture;\n        pix = 0;\n        lim = lengthcount;\n        samplepixels = lengthcount / (3 * samplefac);\n        delta = (samplepixels / ncycles) | 0;\n        alpha = initalpha;\n        radius = initradius;\n\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) {\n            rad = 0;\n        }\n\n        for (i = 0; i < rad; i++) {\n            radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n        }\n\n\n        if (lengthcount < minpicturebytes) {\n            step = 3;\n        } else if ((lengthcount % prime1) !== 0) {\n            step = 3 * prime1;\n        } else {\n\n            if ((lengthcount % prime2) !== 0) {\n                step = 3 * prime2;\n            } else {\n                if ((lengthcount % prime3) !== 0) {\n                    step = 3 * prime3;\n                } else {\n                    step = 3 * prime4;\n                }\n            }\n\n        }\n\n        i = 0;\n\n        while (i < samplepixels) {\n\n            b = (p[pix + 0] & 0xff) << netbiasshift;\n            g = (p[pix + 1] & 0xff) << netbiasshift;\n            r = (p[pix + 2] & 0xff) << netbiasshift;\n            j = contest(b, g, r);\n\n            altersingle(alpha, j, b, g, r);\n\n            if (rad !== 0) {\n                // Alter neighbours\n                alterneigh(rad, j, b, g, r);\n            }\n\n            pix += step;\n\n            if (pix >= lim) {\n                pix -= lengthcount;\n            }\n\n            i++;\n\n            if (delta === 0) {\n                delta = 1;\n            }\n\n            if (i % delta === 0) {\n                alpha -= alpha / alphadec;\n                radius -= radius / radiusdec;\n                rad = radius >> radiusbiasshift;\n\n                if (rad <= 1) {\n                    rad = 0;\n                }\n\n                for (j = 0; j < rad; j++) {\n                    radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n                }\n\n            }\n\n        }\n\n    }\n\n    // Search for BGR values 0..255 (after net is unbiased) and return colour index\n    function map(b, g, r) {\n        var i;\n        var j;\n        var dist;\n        var a;\n        var bestd;\n        var p;\n        var best;\n\n        // Biggest possible distance is 256 * 3\n        bestd = 1000;\n        best = -1;\n        i = netindex[g]; // index on g\n        j = i - 1; // start at netindex[g] and work outwards\n\n        while ((i < netsize) || (j >= 0)) {\n\n            if (i < netsize) {\n\n                p = network[i];\n\n                dist = p[1] - g; // inx key\n\n                if (dist >= bestd) {\n                    i = netsize; // stop iter\n                } else {\n\n                    i++;\n\n                    if (dist < 0) {\n                        dist = -dist;\n                    }\n\n                    a = p[0] - b;\n\n                    if (a < 0) {\n                        a = -a;\n                    }\n\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n\n                        if (a < 0) {\n                            a = -a;\n                        }\n\n                        dist += a;\n\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n\n                }\n\n            }\n\n            if (j >= 0) {\n\n                p = network[j];\n\n                dist = g - p[1]; // inx key - reverse dif\n\n                if (dist >= bestd) {\n                    j = -1; // stop iter\n                } else {\n\n                    j--;\n                    if (dist < 0) {\n                        dist = -dist;\n                    }\n                    a = p[0] - b;\n                    if (a < 0) {\n                        a = -a;\n                    }\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) {\n                            a = -a;\n                        }\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n\n                }\n\n            }\n\n        }\n\n        return (best);\n\n    }\n\n    function process() {\n        learn();\n        unbiasnet();\n        inxbuild();\n        return colorMap();\n    }\n\n    // Unbias network to give byte values 0..255 and record position i\n    // to prepare for sort\n    function unbiasnet() {\n        var i;\n        var j;\n\n        for (i = 0; i < netsize; i++) {\n            network[i][0] >>= netbiasshift;\n            network[i][1] >>= netbiasshift;\n            network[i][2] >>= netbiasshift;\n            network[i][3] = i; // record colour no\n        }\n    }\n\n    // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))\n    // in radpower[|i-j|]\n    function alterneigh(rad, i, b, g, r) {\n\n        var j;\n        var k;\n        var lo;\n        var hi;\n        var a;\n        var m;\n\n        var p;\n\n        lo = i - rad;\n        if (lo < -1) {\n            lo = -1;\n        }\n\n        hi = i + rad;\n\n        if (hi > netsize) {\n            hi = netsize;\n        }\n\n        j = i + 1;\n        k = i - 1;\n        m = 1;\n\n        while ((j < hi) || (k > lo)) {\n\n            a = radpower[m++];\n\n            if (j < hi) {\n\n                p = network[j++];\n\n                try {\n\n                    p[0] -= ((a * (p[0] - b)) / alpharadbias) | 0;\n                    p[1] -= ((a * (p[1] - g)) / alpharadbias) | 0;\n                    p[2] -= ((a * (p[2] - r)) / alpharadbias) | 0;\n\n                } catch (e) {}\n\n            }\n\n            if (k > lo) {\n\n                p = network[k--];\n\n                try {\n\n                    p[0] -= ((a * (p[0] - b)) / alpharadbias) | 0;\n                    p[1] -= ((a * (p[1] - g)) / alpharadbias) | 0;\n                    p[2] -= ((a * (p[2] - r)) / alpharadbias) | 0;\n\n                } catch (e) {}\n\n            }\n\n        }\n\n    }\n\n\n    // Move neuron i towards biased (b,g,r) by factor alpha\n    function altersingle(alpha, i, b, g, r) {\n\n        // alter hit neuron\n        var n = network[i];\n        var alphaMult = alpha / initalpha;\n        n[0] -= ((alphaMult * (n[0] - b))) | 0;\n        n[1] -= ((alphaMult * (n[1] - g))) | 0;\n        n[2] -= ((alphaMult * (n[2] - r))) | 0;\n\n    }\n\n    // Search for biased BGR values\n    function contest(b, g, r) {\n\n        // finds closest neuron (min dist) and updates freq\n        // finds best neuron (min dist-bias) and returns position\n        // for frequently chosen neurons, freq[i] is high and bias[i] is negative\n        // bias[i] = gamma*((1/netsize)-freq[i])\n\n        var i;\n        var dist;\n        var a;\n        var biasdist;\n        var betafreq;\n        var bestpos;\n        var bestbiaspos;\n        var bestd;\n        var bestbiasd;\n        var n;\n\n        bestd = ~(1 << 31);\n        bestbiasd = bestd;\n        bestpos = -1;\n        bestbiaspos = bestpos;\n\n        for (i = 0; i < netsize; i++) {\n\n            n = network[i];\n            dist = n[0] - b;\n\n            if (dist < 0) {\n                dist = -dist;\n            }\n\n            a = n[1] - g;\n\n            if (a < 0) {\n                a = -a;\n            }\n\n            dist += a;\n\n            a = n[2] - r;\n\n            if (a < 0) {\n                a = -a;\n            }\n\n            dist += a;\n\n            if (dist < bestd) {\n                bestd = dist;\n                bestpos = i;\n            }\n\n            biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n\n            if (biasdist < bestbiasd) {\n                bestbiasd = biasdist;\n                bestbiaspos = i;\n            }\n\n            betafreq = (freq[i] >> betashift);\n            freq[i] -= betafreq;\n            bias[i] += (betafreq << gammashift);\n\n        }\n\n        freq[bestpos] += beta;\n        bias[bestpos] -= betagamma;\n        return (bestbiaspos);\n\n    }\n\n    NeuQuantConstructor.apply(this, arguments);\n\n    var exports = {};\n    exports.map = map;\n    exports.process = process;\n\n    return exports;\n}\n\n},{}]},{},[2])'],{type:"text/javascript"})));P.push(C),k.push(C)}var I=function(){for(var n=[],t=0;t<256;t++)n[t]=String.fromCharCode(t);return function(t){for(var e=t.length,i="",a=0;a<e;a++)i+=n[t[a]];return i}}();this.setSize=function(n,t){f=n,h=t,(v=document.createElement("canvas")).width=n,v.height=t,c=v.getContext("2d")},this.setDelay=function(n){b=.1*n},this.setRepeat=function(n){g=n},this.addFrame=function(n){null===c&&this.setSize(f,h),c.drawImage(n,0,0,f,h);var t=c.getImageData(0,0,f,h);this.addFrameImageData(t)},this.addFrameImageData=function(n){var t=(n.length,new Uint8Array(n.data));m.push({data:t,width:n.width,height:n.height,palette:u,dithering:p,done:!1,beingProcessed:!1,position:m.length})},this.onRenderProgress=function(n){y=n},this.isRendering=function(){return j},this.getBase64GIF=function(n){e(function(t){var e=I(t),i="data:image/gif;base64,"+btoa(e);n(i)})},this.getBlobGIF=function(n){e(function(t){var e=new Uint8Array(t),i=new Blob([e],{type:"image/gif"});n(i)})},this.destroy=function(){P.forEach(function(n){n.terminate()})}}},{omggif:1}]},{},[2])(2)});